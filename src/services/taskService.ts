/**
 * Task Service
 *
 * Handles all Firestore operations for tasks:
 * - Create, Read, Update, Delete
 * - Real-time subscriptions
 * - User-specific queries
 *
 * Provides data conversion between Task objects and Firestore DocumentData format.
 */

import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  getDocs,
  query,
  where,
  onSnapshot,
  Timestamp,
  QuerySnapshot,
  DocumentData,
  Unsubscribe,
} from 'firebase/firestore';
import { db } from './firebase';
import { Task } from '../types/task';
import { logger } from '../utils/logger';

const TASKS_COLLECTION = 'tasks';

/**
 * Convert Firestore Timestamp to Date
 *
 * @param timestamp - Firestore Timestamp or Date object
 * @returns Date object or undefined
 */
const timestampToDate = (timestamp: Timestamp | Date | undefined): Date | undefined => {
  if (!timestamp) return undefined;
  if (timestamp instanceof Date) return timestamp;
  return timestamp.toDate();
};

/**
 * Convert Task to Firestore format
 *
 * Removes undefined values (Firestore doesn't accept undefined) and converts
 * Date objects to Firestore Timestamps.
 *
 * @param task - Task object to convert
 * @returns Firestore DocumentData object
 */
const taskToFirestore = (task: Task): DocumentData => {
  const data: DocumentData = {
    title: task.title,
    status: task.status,
    group: task.group,
    userId: task.userId,
    createdAt: task.createdAt ? Timestamp.fromDate(task.createdAt) : Timestamp.now(),
    updatedAt: task.updatedAt ? Timestamp.fromDate(task.updatedAt) : Timestamp.now(),
    // Ensure order is always a number (default to 0 if undefined)
    order: task.order ?? 0,
  };

  // Only include optional fields if they have values (not undefined)
  if (task.description !== undefined && task.description !== null && task.description !== '') {
    data.description = task.description;
  }

  if (task.priority !== undefined && task.priority !== null) {
    data.priority = task.priority;
  }

  if (task.parentId !== undefined && task.parentId !== null) {
    data.parentId = task.parentId;
  }

  if (task.completedAt !== undefined && task.completedAt !== null) {
    data.completedAt = Timestamp.fromDate(task.completedAt);
  }

  return data;
};

/**
 * Convert Firestore document to Task
 *
 * @param docData - Firestore document data
 * @param id - Document ID
 * @returns Task object
 */
const firestoreToTask = (docData: DocumentData, id: string): Task => {
  return {
    id,
    title: docData.title,
    status: docData.status || 'open',
    group: docData.group || 'General',
    userId: docData.userId,
    description: docData.description || undefined,
    priority: docData.priority || undefined,
    parentId: docData.parentId || undefined,
    order: docData.order ?? 0,
    createdAt: timestampToDate(docData.createdAt) || new Date(),
    updatedAt: timestampToDate(docData.updatedAt) || new Date(),
    completedAt: timestampToDate(docData.completedAt),
  } as Task;
};

/**
 * Sort tasks by order (handles undefined orders)
 *
 * @param tasks - Array of tasks to sort
 * @returns Sorted array of tasks
 */
const sortTasksByOrder = (tasks: Task[]): Task[] => {
  return tasks.sort((a, b) => {
    const orderA = a.order ?? 0;
    const orderB = b.order ?? 0;
    return orderA - orderB;
  });
};

/**
 * Get all tasks for a user
 *
 * Fetches all tasks from Firestore for the specified user and returns them sorted by order.
 *
 * @param userId - User ID to fetch tasks for
 * @returns Array of tasks sorted by order
 * @throws Error if Firestore query fails
 */
export const getTasks = async (userId: string): Promise<Task[]> => {
  const tasksRef = collection(db, TASKS_COLLECTION);
  const q = query(tasksRef, where('userId', '==', userId));

  const querySnapshot = await getDocs(q);
  const tasks = querySnapshot.docs.map((doc) => firestoreToTask(doc.data(), doc.id));

  return sortTasksByOrder(tasks);
};

/**
 * Subscribe to real-time task updates for a user
 *
 * Sets up a Firestore listener that triggers the callback whenever tasks change.
 * Returns an unsubscribe function to stop listening.
 *
 * @param userId - User ID to subscribe to
 * @param callback - Function called with updated tasks array whenever data changes
 * @returns Unsubscribe function to stop the listener
 */
export const subscribeToTasks = (
  userId: string,
  callback: (tasks: Task[]) => void
): Unsubscribe => {
  const tasksRef = collection(db, TASKS_COLLECTION);
  // Sort in memory because order might be undefined for some tasks
  const q = query(tasksRef, where('userId', '==', userId));

  return onSnapshot(q, (snapshot: QuerySnapshot<DocumentData>) => {
    const tasks = snapshot.docs.map((doc) => firestoreToTask(doc.data(), doc.id));
    const sortedTasks = sortTasksByOrder(tasks);
    callback(sortedTasks);
  });
};

/**
 * Create a new task in Firestore
 *
 * @param task - Task object without ID (ID will be generated by Firestore)
 * @returns Firestore document ID of the created task
 * @throws Error if Firestore operation fails
 */
export const createTask = async (task: Omit<Task, 'id'>): Promise<string> => {
  try {
    const tasksRef = collection(db, TASKS_COLLECTION);
    const taskData = taskToFirestore(task as Task);
    logger.log('Creating task in Firestore:', { taskData, collection: TASKS_COLLECTION });
    const docRef = await addDoc(tasksRef, taskData);
    logger.log('Task created successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error) {
    logger.error('Error creating task in Firestore:', error);
    throw error;
  }
};

/**
 * Update an existing task in Firestore
 *
 * Updates specified fields of a task. Removes undefined values (Firestore doesn't accept undefined).
 * Automatically updates the `updatedAt` timestamp.
 *
 * @param taskId - Task ID to update
 * @param updates - Partial task object with fields to update
 * @throws Error if Firestore operation fails
 */
export const updateTask = async (taskId: string, updates: Partial<Task>): Promise<void> => {
  const taskRef = doc(db, TASKS_COLLECTION, taskId);
  const updateData: DocumentData = {
    updatedAt: Timestamp.now(),
  };

  // Only include fields that are defined (not undefined)
  if (updates.title !== undefined) updateData.title = updates.title;
  if (updates.description !== undefined) {
    updateData.description = updates.description || null;
  }
  if (updates.status !== undefined) updateData.status = updates.status;
  if (updates.group !== undefined) updateData.group = updates.group;
  if (updates.priority !== undefined) {
    updateData.priority = updates.priority || null;
  }
  if (updates.parentId !== undefined) {
    updateData.parentId = updates.parentId || null;
  }
  if (updates.order !== undefined) updateData.order = updates.order ?? 0;

  // Handle date fields
  if (updates.completedAt !== undefined) {
    updateData.completedAt = updates.completedAt ? Timestamp.fromDate(updates.completedAt) : null;
  }

  await updateDoc(taskRef, updateData);
};

/**
 * Delete a task from Firestore
 *
 * @param taskId - Task ID to delete
 * @throws Error if Firestore operation fails
 */
export const deleteTask = async (taskId: string): Promise<void> => {
  const taskRef = doc(db, TASKS_COLLECTION, taskId);
  await deleteDoc(taskRef);
};

/**
 * Delete a task and all its subtasks from Firestore
 *
 * Finds all subtasks of the specified task and deletes them along with the parent task.
 *
 * @param taskId - Parent task ID to delete
 * @param allTasks - Array of all tasks to search for subtasks
 * @throws Error if Firestore operation fails
 */
export const deleteTaskWithSubtasks = async (taskId: string, allTasks: Task[]): Promise<void> => {
  // Get all subtask IDs
  const subtaskIds = allTasks.filter((task) => task.parentId === taskId).map((task) => task.id);

  // Delete the main task
  await deleteTask(taskId);

  // Delete all subtasks
  await Promise.all(subtaskIds.map((id) => deleteTask(id)));
};
