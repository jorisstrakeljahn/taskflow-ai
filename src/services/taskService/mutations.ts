/**
 * Task Mutations
 *
 * Functions for creating, updating, and deleting tasks in Firestore.
 * Handles all write operations.
 */

import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  Timestamp,
  DocumentData,
} from 'firebase/firestore';
import { db } from '../firebase';
import { Task } from '../../types/task';
import { logger } from '../../utils/logger';
import { taskToFirestore } from './converters';

const TASKS_COLLECTION = 'tasks';

/**
 * Create a new task in Firestore
 *
 * @param task - Task object without ID (ID will be generated by Firestore)
 * @returns The ID of the created task
 * @throws Error if Firestore operation fails
 */
export const createTask = async (task: Omit<Task, 'id'>): Promise<string> => {
  try {
    const tasksRef = collection(db, TASKS_COLLECTION);
    const taskData = taskToFirestore(task as Task);
    logger.log('Creating task in Firestore:', { taskData, collection: TASKS_COLLECTION });
    const docRef = await addDoc(tasksRef, taskData);
    logger.log('Task created successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error) {
    logger.error('Error creating task in Firestore:', error);
    throw error;
  }
};

/**
 * Update an existing task in Firestore
 *
 * Updates specified fields of a task. Removes undefined values (Firestore doesn't accept undefined).
 * Automatically updates the `updatedAt` timestamp.
 *
 * @param taskId - Task ID to update
 * @param updates - Partial task object with fields to update
 * @throws Error if Firestore operation fails
 */
export const updateTask = async (taskId: string, updates: Partial<Task>): Promise<void> => {
  const taskRef = doc(db, TASKS_COLLECTION, taskId);
  const updateData: DocumentData = {
    updatedAt: Timestamp.now(),
  };

  // Only include fields that are defined (not undefined)
  if (updates.title !== undefined) updateData.title = updates.title;
  if (updates.description !== undefined) {
    updateData.description = updates.description || null;
  }
  if (updates.status !== undefined) updateData.status = updates.status;
  if (updates.group !== undefined) updateData.group = updates.group;
  if (updates.priority !== undefined) {
    updateData.priority = updates.priority || null;
  }
  if (updates.parentId !== undefined) {
    updateData.parentId = updates.parentId || null;
  }
  if (updates.order !== undefined) updateData.order = updates.order ?? 0;

  // Handle date fields
  if (updates.completedAt !== undefined) {
    updateData.completedAt = updates.completedAt ? Timestamp.fromDate(updates.completedAt) : null;
  }
  if (updates.dueDate !== undefined) {
    updateData.dueDate = updates.dueDate ? Timestamp.fromDate(updates.dueDate) : null;
  }

  try {
    await updateDoc(taskRef, updateData);
    logger.log('Task updated successfully:', taskId);
  } catch (error) {
    logger.error('Error updating task in Firestore:', error);
    throw error;
  }
};

/**
 * Delete a task from Firestore
 *
 * @param taskId - Task ID to delete
 * @throws Error if Firestore operation fails
 */
export const deleteTask = async (taskId: string): Promise<void> => {
  const taskRef = doc(db, TASKS_COLLECTION, taskId);
  try {
    await deleteDoc(taskRef);
    logger.log('Task deleted successfully:', taskId);
  } catch (error) {
    logger.error('Error deleting task from Firestore:', error);
    throw error;
  }
};

/**
 * Delete a task and all its subtasks recursively
 *
 * @param taskId - Task ID to delete
 * @param allTasks - Array of all tasks (to find subtasks)
 * @throws Error if Firestore operation fails
 */
export const deleteTaskWithSubtasks = async (taskId: string, allTasks: Task[]): Promise<void> => {
  // Find all subtasks recursively
  const findSubtasks = (parentId: string): Task[] => {
    const directSubtasks = allTasks.filter((task) => task.parentId === parentId);
    const allSubtasks = [...directSubtasks];

    // Recursively find subtasks of subtasks
    for (const subtask of directSubtasks) {
      allSubtasks.push(...findSubtasks(subtask.id));
    }

    return allSubtasks;
  };

  const subtasks = findSubtasks(taskId);

  try {
    // Delete all subtasks first
    for (const subtask of subtasks) {
      await deleteTask(subtask.id);
    }

    // Delete the parent task
    await deleteTask(taskId);

    logger.log(`Deleted task ${taskId} and ${subtasks.length} subtask(s)`);
  } catch (error) {
    logger.error('Error deleting task with subtasks:', error);
    throw error;
  }
};
